{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport React, { createContext, useContext, useRef, useState } from 'react';\nimport { useLayoutEffect } from '../utils/use-layout-effect';\nimport { useUniqueId } from '../utils/use-unique-id';\nvar StaggeredEntranceContext = /*#__PURE__*/createContext(function () {\n  return {\n    isReady: true,\n    delay: 0,\n    ref: function ref() {}\n  };\n});\nexport var useStaggeredEntrance = function useStaggeredEntrance() {\n  var indentifier = useUniqueId();\n  var context = useContext(StaggeredEntranceContext);\n  return context(indentifier);\n};\n/**\n * For a list of elements that need to animate in,\n * this should be used in conjunction with entering components.\n * This does not need Javascript to execute so it will run immediately for any SSR rendered React apps before the JS has executed.\n *\n * Will dynamically add delay to each child entering component.\n * Unfortunately all entering components _NEED_ to be a direct descendant.\n */\n\nvar StaggeredEntrance = function StaggeredEntrance(_ref) {\n  var children = _ref.children,\n      column = _ref.column,\n      _ref$columns = _ref.columns,\n      columns = _ref$columns === void 0 ? 'responsive' : _ref$columns,\n      _ref$delayStep = _ref.delayStep,\n      delayStep = _ref$delayStep === void 0 ? 50 : _ref$delayStep;\n  var elementRefs = useRef([]);\n  var indexes = [];\n\n  var _useState = useState(function () {\n    if (typeof columns === 'number') {\n      // A hardcoded columns is set so bail out and set it to that!\n      return columns;\n    }\n\n    if (typeof column === 'number') {\n      // A hardcoded column is set so we will set actualColumns to be 1.\n      return 1;\n    } // We are in \"responsive\" mode.\n    // So we will be calculating when the Javascript executes on the client how many columns there will be.\n    // We are in \"responsive\" mode.\n    // So we will be calculating when the Javascript executes on the client how many columns there will be.\n\n\n    return 0;\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      actualColumns = _useState2[0],\n      setActualColumns = _useState2[1];\n\n  useLayoutEffect(function () {\n    // We want to only run this code when we are in \"responsive\" mode.\n    // It is assumed we are in responsive mode if `columns` is \"responsive\",\n    // we have children element refs ready to be read (i.e. if there are no children this won't run as well)\n    // and finally that `actualColumns` is `0` - this is because for the first render cycle `actualColumns` will be `0` (set above)\n    // and then after this layout effect runs the value for `actualColumns` will then be calculated and set.\n    if (columns === 'responsive' && elementRefs.current.length && actualColumns === 0) {\n      var currentTop = 0;\n      var numberColumns = 0;\n\n      if (elementRefs.current.length <= 1) {\n        setActualColumns(1);\n        return;\n      } // We set the current top to the first elements.\n      // We will be comparing this and incrementing the column count\n      // until we hit an element that has a different offset top (or we run out of elements).\n\n\n      currentTop = elementRefs.current[0] ? elementRefs.current[0].offsetTop : 0;\n\n      for (var i = 0; i < elementRefs.current.length; i++) {\n        var child = elementRefs.current[i];\n\n        if (!child) {\n          break;\n        }\n\n        if (currentTop === child.offsetTop) {\n          numberColumns += 1;\n\n          if (elementRefs.current.length - 1 === i) {\n            setActualColumns(numberColumns);\n          }\n\n          continue;\n        }\n\n        setActualColumns(numberColumns);\n        break;\n      }\n    } // We only want this effect to run once - on initial mount.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  return /*#__PURE__*/React.createElement(StaggeredEntranceContext.Provider, {\n    value: function value(id) {\n      if (!indexes.includes(id)) {\n        indexes.push(id);\n      }\n\n      var isReady = actualColumns > 0;\n      var index = indexes.indexOf(id);\n      var currentColumn = column || index % actualColumns;\n      var currentRow = Math.floor(index / actualColumns);\n      var distanceFromTopLeftElement = currentRow + currentColumn; // We don't want loads of elements to have the same staggered delay as it ends up looking slow for users.\n      // To get around that we calculate the logarithm using `distanceFromTopLeftElement` which ends making\n      // elements appear faster the further away from the top left element.\n\n      var delay = Math.ceil(Math.log(distanceFromTopLeftElement + 1) * delayStep * 1.5) || 0;\n      return {\n        delay: delay,\n        isReady: isReady,\n        ref: function ref(element) {\n          return elementRefs.current[index] = element;\n        }\n      };\n    }\n  }, children);\n};\n\nexport default StaggeredEntrance;","map":{"version":3,"sources":["D:/unipr/Telematica/Progetto/Telematica/frontend/node_modules/@atlaskit/tooltip/node_modules/@atlaskit/motion/dist/esm/entering/staggered-entrance.js"],"names":["_slicedToArray","React","createContext","useContext","useRef","useState","useLayoutEffect","useUniqueId","StaggeredEntranceContext","isReady","delay","ref","useStaggeredEntrance","indentifier","context","StaggeredEntrance","_ref","children","column","_ref$columns","columns","_ref$delayStep","delayStep","elementRefs","indexes","_useState","_useState2","actualColumns","setActualColumns","current","length","currentTop","numberColumns","offsetTop","i","child","createElement","Provider","value","id","includes","push","index","indexOf","currentColumn","currentRow","Math","floor","distanceFromTopLeftElement","ceil","log","element"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport React, { createContext, useContext, useRef, useState } from 'react';\nimport { useLayoutEffect } from '../utils/use-layout-effect';\nimport { useUniqueId } from '../utils/use-unique-id';\nvar StaggeredEntranceContext = /*#__PURE__*/createContext(function () {\n  return {\n    isReady: true,\n    delay: 0,\n    ref: function ref() {}\n  };\n});\nexport var useStaggeredEntrance = function useStaggeredEntrance() {\n  var indentifier = useUniqueId();\n  var context = useContext(StaggeredEntranceContext);\n  return context(indentifier);\n};\n/**\n * For a list of elements that need to animate in,\n * this should be used in conjunction with entering components.\n * This does not need Javascript to execute so it will run immediately for any SSR rendered React apps before the JS has executed.\n *\n * Will dynamically add delay to each child entering component.\n * Unfortunately all entering components _NEED_ to be a direct descendant.\n */\n\nvar StaggeredEntrance = function StaggeredEntrance(_ref) {\n  var children = _ref.children,\n      column = _ref.column,\n      _ref$columns = _ref.columns,\n      columns = _ref$columns === void 0 ? 'responsive' : _ref$columns,\n      _ref$delayStep = _ref.delayStep,\n      delayStep = _ref$delayStep === void 0 ? 50 : _ref$delayStep;\n  var elementRefs = useRef([]);\n  var indexes = [];\n\n  var _useState = useState(function () {\n    if (typeof columns === 'number') {\n      // A hardcoded columns is set so bail out and set it to that!\n      return columns;\n    }\n\n    if (typeof column === 'number') {\n      // A hardcoded column is set so we will set actualColumns to be 1.\n      return 1;\n    } // We are in \"responsive\" mode.\n    // So we will be calculating when the Javascript executes on the client how many columns there will be.\n\n\n    // We are in \"responsive\" mode.\n    // So we will be calculating when the Javascript executes on the client how many columns there will be.\n    return 0;\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      actualColumns = _useState2[0],\n      setActualColumns = _useState2[1];\n\n  useLayoutEffect(function () {\n    // We want to only run this code when we are in \"responsive\" mode.\n    // It is assumed we are in responsive mode if `columns` is \"responsive\",\n    // we have children element refs ready to be read (i.e. if there are no children this won't run as well)\n    // and finally that `actualColumns` is `0` - this is because for the first render cycle `actualColumns` will be `0` (set above)\n    // and then after this layout effect runs the value for `actualColumns` will then be calculated and set.\n    if (columns === 'responsive' && elementRefs.current.length && actualColumns === 0) {\n      var currentTop = 0;\n      var numberColumns = 0;\n\n      if (elementRefs.current.length <= 1) {\n        setActualColumns(1);\n        return;\n      } // We set the current top to the first elements.\n      // We will be comparing this and incrementing the column count\n      // until we hit an element that has a different offset top (or we run out of elements).\n\n\n      currentTop = elementRefs.current[0] ? elementRefs.current[0].offsetTop : 0;\n\n      for (var i = 0; i < elementRefs.current.length; i++) {\n        var child = elementRefs.current[i];\n\n        if (!child) {\n          break;\n        }\n\n        if (currentTop === child.offsetTop) {\n          numberColumns += 1;\n\n          if (elementRefs.current.length - 1 === i) {\n            setActualColumns(numberColumns);\n          }\n\n          continue;\n        }\n\n        setActualColumns(numberColumns);\n        break;\n      }\n    } // We only want this effect to run once - on initial mount.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  return /*#__PURE__*/React.createElement(StaggeredEntranceContext.Provider, {\n    value: function value(id) {\n      if (!indexes.includes(id)) {\n        indexes.push(id);\n      }\n\n      var isReady = actualColumns > 0;\n      var index = indexes.indexOf(id);\n      var currentColumn = column || index % actualColumns;\n      var currentRow = Math.floor(index / actualColumns);\n      var distanceFromTopLeftElement = currentRow + currentColumn; // We don't want loads of elements to have the same staggered delay as it ends up looking slow for users.\n      // To get around that we calculate the logarithm using `distanceFromTopLeftElement` which ends making\n      // elements appear faster the further away from the top left element.\n\n      var delay = Math.ceil(Math.log(distanceFromTopLeftElement + 1) * delayStep * 1.5) || 0;\n      return {\n        delay: delay,\n        isReady: isReady,\n        ref: function ref(element) {\n          return elementRefs.current[index] = element;\n        }\n      };\n    }\n  }, children);\n};\n\nexport default StaggeredEntrance;"]},"metadata":{},"sourceType":"module"}