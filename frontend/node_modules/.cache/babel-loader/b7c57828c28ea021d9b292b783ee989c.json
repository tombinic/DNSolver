{"ast":null,"code":"import React, { Children, createContext, memo, useContext, useMemo, useRef } from 'react';\nimport { isReducedMotion } from '../utils/accessibility';\nimport { useForceRender } from '../utils/use-force-render';\n/**\n * Internally we will be playing with an element that will always have a key defined.\n */\n// We define empty context here so the object doesn't change.\n\nvar emptyContext = {\n  // Motions will always appear if not inside a exiting persistence component.\n  appear: true,\n  isExiting: false\n};\nvar ExitingContext = /*#__PURE__*/createContext(emptyContext);\n\nvar isAnyPreviousKeysMissingFromCurrent = function isAnyPreviousKeysMissingFromCurrent(currentMap, previous) {\n  for (var i = 0; i < previous.length; i++) {\n    var element = previous[i];\n    var _key = element.key;\n\n    if (!currentMap[_key]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * This method will wrap any React element with a context provider. We're using context (instead of\n * cloneElement) so we can communicate between multiple elements without the need of prop drilling\n * (results in a better API for consumers).\n */\n\n\nvar wrapChildWithContextProvider = function wrapChildWithContextProvider(child) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyContext;\n  return /*#__PURE__*/React.createElement(ExitingContext.Provider, {\n    key: \"\".concat(child.key, \"-provider\"),\n    value: value\n  }, child);\n};\n\nvar childrenToObj = function childrenToObj(children) {\n  return children.reduce(function (acc, child) {\n    acc[child.key] = child;\n    return acc;\n  }, {});\n};\n\nvar spliceNewElementsIntoPrevious = function spliceNewElementsIntoPrevious(current, previous) {\n  var splicedChildren = previous.concat([]);\n  var previousMap = childrenToObj(previous);\n\n  for (var i = 0; i < current.length; i++) {\n    var child = current[i];\n    var childIsNew = !previousMap[child.key];\n\n    if (childIsNew) {\n      // This will insert the new element after the previous element.\n      splicedChildren.splice(i + 1, 0, child);\n    }\n  }\n\n  return splicedChildren;\n};\n/**\n * This function will convert all children types to an array while also filtering out non-valid React elements.\n */\n\n\nvar childrenToArray = function childrenToArray(children) {\n  var childrenAsArray = []; // We convert children to an array using this helper method as it will add keys to children that do not\n  // have them, such as when we have hardcoded children that are conditionally rendered.\n\n  Children.toArray(children).forEach(function (child) {\n    // We ignore any boolean children to make our code a little more simple later on,\n    // and also filter out any falsies (empty strings, nulls, and undefined).\n    if (typeof child !== 'boolean' && Boolean(child)) {\n      // Children WILL have a key after being forced into an array using the React.Children helper.\n      childrenAsArray.push(child);\n    }\n  });\n  return childrenAsArray;\n};\n/**\n * This handles the case when a render updates during an exit motion.\n * If any child is mounted again we removed them from the exiting children object and return true.\n */\n\n\nvar hasAnyExitingChildMountedAgain = function hasAnyExitingChildMountedAgain(exitingChildren, children) {\n  var exitingChildMountedAgain = false;\n  children.forEach(function (child) {\n    if (exitingChildren.current[child.key]) {\n      exitingChildMountedAgain = true;\n      delete exitingChildren.current[child.key];\n    }\n  });\n  return exitingChildMountedAgain;\n};\n\nvar ExitingPersistence = /*#__PURE__*/memo(function (_ref) {\n  var _ref$appear = _ref.appear,\n      appearFromProp = _ref$appear === void 0 ? false : _ref$appear,\n      childs = _ref.children,\n      exitThenEnter = _ref.exitThenEnter;\n  var children = childrenToArray(childs);\n  var childrenObj = childrenToObj(children);\n  var previousChildren = useRef([]);\n  var persistedChildren = useRef([]);\n  var forceRender = useForceRender();\n  var exitingChildren = useRef({});\n  var appear = useRef(appearFromProp);\n  var defaultContextValue = useMemo(function () {\n    return {\n      appear: appear.current,\n      isExiting: false\n    };\n  }, // React rules of hooks says this isn't needed because mutating appear won't cause a re-render.\n  // While technically true - it will trigger this to make a new object on the _next_ render which is what we want.\n  // Remove this or use appear instead of appear.current and you will notice a test breaks.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [appear.current]);\n\n  if (isReducedMotion()) {\n    return children;\n  }\n\n  if (!appear.current) {\n    // We always want child motions to appear after the initial mount.\n    appear.current = true;\n  } // This entire block can't be an effect because we need it to run synchronously during a render\n  // else when elements are being removed they will be remounted instead of being updated.\n\n\n  if (previousChildren.current.length && isAnyPreviousKeysMissingFromCurrent(childrenObj, previousChildren.current)) {\n    if (persistedChildren.current.length === 0 || hasAnyExitingChildMountedAgain(exitingChildren, children)) {\n      persistedChildren.current = previousChildren.current;\n    } // We have persisted children now set from previous children.\n    // Let's update previous children so we have it available next render.\n\n\n    previousChildren.current = children;\n    return (exitThenEnter ? persistedChildren.current : spliceNewElementsIntoPrevious(children, persistedChildren.current)).map(function (child) {\n      var currentChild = childrenObj[child.key];\n\n      if (!currentChild) {\n        // We've found an exiting child - mark it!\n        exitingChildren.current[child.key] = true;\n        return wrapChildWithContextProvider(child, {\n          isExiting: true,\n          appear: true,\n          onFinish: function onFinish() {\n            delete exitingChildren.current[child.key]; // We will only remove the exiting elements when any subsequent exiting elements have also finished.\n            // Think of removing many items from a todo list - when removing a few over a few clicks we don't\n            // want the list jumping around when they exit.\n\n            if (Object.keys(exitingChildren.current).length === 0) {\n              // Set previous children to nothing.\n              // This let's us skip the next render check as it's assumed children and previous will be the same.\n              previousChildren.current = [];\n              persistedChildren.current = []; // Re-render after the element(s) have animated away which will end up rendering the latest children.\n\n              forceRender();\n            }\n          }\n        });\n      } // This element isn't exiting.\n      // Wrap context and let's continue on our way.\n\n\n      return wrapChildWithContextProvider(currentChild, defaultContextValue);\n    });\n  } else {\n    previousChildren.current = children;\n  }\n\n  return children.map(function (child) {\n    return wrapChildWithContextProvider(child, defaultContextValue);\n  });\n});\nexport var useExitingPersistence = function useExitingPersistence() {\n  return useContext(ExitingContext);\n};\nExitingPersistence.displayName = 'ExitingPersistence';\nexport default ExitingPersistence;","map":{"version":3,"sources":["D:/unipr/Telematica/Progetto/Telematica/frontend/node_modules/@atlaskit/tooltip/node_modules/@atlaskit/motion/dist/esm/entering/exiting-persistence.js"],"names":["React","Children","createContext","memo","useContext","useMemo","useRef","isReducedMotion","useForceRender","emptyContext","appear","isExiting","ExitingContext","isAnyPreviousKeysMissingFromCurrent","currentMap","previous","i","length","element","_key","key","wrapChildWithContextProvider","child","value","arguments","undefined","createElement","Provider","concat","childrenToObj","children","reduce","acc","spliceNewElementsIntoPrevious","current","splicedChildren","previousMap","childIsNew","splice","childrenToArray","childrenAsArray","toArray","forEach","Boolean","push","hasAnyExitingChildMountedAgain","exitingChildren","exitingChildMountedAgain","ExitingPersistence","_ref","_ref$appear","appearFromProp","childs","exitThenEnter","childrenObj","previousChildren","persistedChildren","forceRender","defaultContextValue","map","currentChild","onFinish","Object","keys","useExitingPersistence","displayName"],"mappings":"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","sourcesContent":["import React, { Children, createContext, memo, useContext, useMemo, useRef } from 'react';\nimport { isReducedMotion } from '../utils/accessibility';\nimport { useForceRender } from '../utils/use-force-render';\n/**\n * Internally we will be playing with an element that will always have a key defined.\n */\n\n// We define empty context here so the object doesn't change.\nvar emptyContext = {\n  // Motions will always appear if not inside a exiting persistence component.\n  appear: true,\n  isExiting: false\n};\nvar ExitingContext = /*#__PURE__*/createContext(emptyContext);\n\nvar isAnyPreviousKeysMissingFromCurrent = function isAnyPreviousKeysMissingFromCurrent(currentMap, previous) {\n  for (var i = 0; i < previous.length; i++) {\n    var element = previous[i];\n    var _key = element.key;\n\n    if (!currentMap[_key]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * This method will wrap any React element with a context provider. We're using context (instead of\n * cloneElement) so we can communicate between multiple elements without the need of prop drilling\n * (results in a better API for consumers).\n */\n\n\nvar wrapChildWithContextProvider = function wrapChildWithContextProvider(child) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyContext;\n  return /*#__PURE__*/React.createElement(ExitingContext.Provider, {\n    key: \"\".concat(child.key, \"-provider\"),\n    value: value\n  }, child);\n};\n\nvar childrenToObj = function childrenToObj(children) {\n  return children.reduce(function (acc, child) {\n    acc[child.key] = child;\n    return acc;\n  }, {});\n};\n\nvar spliceNewElementsIntoPrevious = function spliceNewElementsIntoPrevious(current, previous) {\n  var splicedChildren = previous.concat([]);\n  var previousMap = childrenToObj(previous);\n\n  for (var i = 0; i < current.length; i++) {\n    var child = current[i];\n    var childIsNew = !previousMap[child.key];\n\n    if (childIsNew) {\n      // This will insert the new element after the previous element.\n      splicedChildren.splice(i + 1, 0, child);\n    }\n  }\n\n  return splicedChildren;\n};\n/**\n * This function will convert all children types to an array while also filtering out non-valid React elements.\n */\n\n\nvar childrenToArray = function childrenToArray(children) {\n  var childrenAsArray = []; // We convert children to an array using this helper method as it will add keys to children that do not\n  // have them, such as when we have hardcoded children that are conditionally rendered.\n\n  Children.toArray(children).forEach(function (child) {\n    // We ignore any boolean children to make our code a little more simple later on,\n    // and also filter out any falsies (empty strings, nulls, and undefined).\n    if (typeof child !== 'boolean' && Boolean(child)) {\n      // Children WILL have a key after being forced into an array using the React.Children helper.\n      childrenAsArray.push(child);\n    }\n  });\n  return childrenAsArray;\n};\n/**\n * This handles the case when a render updates during an exit motion.\n * If any child is mounted again we removed them from the exiting children object and return true.\n */\n\n\nvar hasAnyExitingChildMountedAgain = function hasAnyExitingChildMountedAgain(exitingChildren, children) {\n  var exitingChildMountedAgain = false;\n  children.forEach(function (child) {\n    if (exitingChildren.current[child.key]) {\n      exitingChildMountedAgain = true;\n      delete exitingChildren.current[child.key];\n    }\n  });\n  return exitingChildMountedAgain;\n};\n\nvar ExitingPersistence = /*#__PURE__*/memo(function (_ref) {\n  var _ref$appear = _ref.appear,\n      appearFromProp = _ref$appear === void 0 ? false : _ref$appear,\n      childs = _ref.children,\n      exitThenEnter = _ref.exitThenEnter;\n  var children = childrenToArray(childs);\n  var childrenObj = childrenToObj(children);\n  var previousChildren = useRef([]);\n  var persistedChildren = useRef([]);\n  var forceRender = useForceRender();\n  var exitingChildren = useRef({});\n  var appear = useRef(appearFromProp);\n  var defaultContextValue = useMemo(function () {\n    return {\n      appear: appear.current,\n      isExiting: false\n    };\n  }, // React rules of hooks says this isn't needed because mutating appear won't cause a re-render.\n  // While technically true - it will trigger this to make a new object on the _next_ render which is what we want.\n  // Remove this or use appear instead of appear.current and you will notice a test breaks.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [appear.current]);\n\n  if (isReducedMotion()) {\n    return children;\n  }\n\n  if (!appear.current) {\n    // We always want child motions to appear after the initial mount.\n    appear.current = true;\n  } // This entire block can't be an effect because we need it to run synchronously during a render\n  // else when elements are being removed they will be remounted instead of being updated.\n\n\n  if (previousChildren.current.length && isAnyPreviousKeysMissingFromCurrent(childrenObj, previousChildren.current)) {\n    if (persistedChildren.current.length === 0 || hasAnyExitingChildMountedAgain(exitingChildren, children)) {\n      persistedChildren.current = previousChildren.current;\n    } // We have persisted children now set from previous children.\n    // Let's update previous children so we have it available next render.\n\n\n    previousChildren.current = children;\n    return (exitThenEnter ? persistedChildren.current : spliceNewElementsIntoPrevious(children, persistedChildren.current)).map(function (child) {\n      var currentChild = childrenObj[child.key];\n\n      if (!currentChild) {\n        // We've found an exiting child - mark it!\n        exitingChildren.current[child.key] = true;\n        return wrapChildWithContextProvider(child, {\n          isExiting: true,\n          appear: true,\n          onFinish: function onFinish() {\n            delete exitingChildren.current[child.key]; // We will only remove the exiting elements when any subsequent exiting elements have also finished.\n            // Think of removing many items from a todo list - when removing a few over a few clicks we don't\n            // want the list jumping around when they exit.\n\n            if (Object.keys(exitingChildren.current).length === 0) {\n              // Set previous children to nothing.\n              // This let's us skip the next render check as it's assumed children and previous will be the same.\n              previousChildren.current = [];\n              persistedChildren.current = []; // Re-render after the element(s) have animated away which will end up rendering the latest children.\n\n              forceRender();\n            }\n          }\n        });\n      } // This element isn't exiting.\n      // Wrap context and let's continue on our way.\n\n\n      return wrapChildWithContextProvider(currentChild, defaultContextValue);\n    });\n  } else {\n    previousChildren.current = children;\n  }\n\n  return children.map(function (child) {\n    return wrapChildWithContextProvider(child, defaultContextValue);\n  });\n});\nexport var useExitingPersistence = function useExitingPersistence() {\n  return useContext(ExitingContext);\n};\nExitingPersistence.displayName = 'ExitingPersistence';\nexport default ExitingPersistence;"]},"metadata":{},"sourceType":"module"}