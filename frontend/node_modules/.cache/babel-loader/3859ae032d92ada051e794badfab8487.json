{"ast":null,"code":"import { useCallback, useEffect, useRef } from 'react';\n\nvar getHookDeps = function getHookDeps(opts) {\n  switch (opts.cleanup) {\n    case 'next-effect':\n      return undefined;\n\n    case 'unmount':\n    default:\n      return [];\n  }\n};\n/**\n * Will return request animation frame as a function which will clean itself up.\n */\n\n\nexport var useRequestAnimationFrame = function useRequestAnimationFrame() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    cleanup: 'unmount'\n  };\n  var frames = useRef([]);\n  useEffect(function () {\n    return function () {\n      if (frames.current.length) {\n        frames.current.forEach(function (id) {\n          return cancelAnimationFrame(id);\n        });\n        frames.current = [];\n      }\n    }; // We dynamically set this so we either clean up on the next effect - or on unmount.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, getHookDeps(opts));\n  return useCallback(function (handler) {\n    var id = requestAnimationFrame(function (time) {\n      frames.current = frames.current.filter(function (frameId) {\n        return frameId !== id;\n      });\n      handler(time);\n    });\n    frames.current.push(id);\n  }, []);\n};\n/**\n * Will return set  timeout as a function which will clean itself up.\n */\n\nexport var useSetTimeout = function useSetTimeout() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    cleanup: 'unmount'\n  };\n  var timeouts = useRef([]);\n  useEffect(function () {\n    return function () {\n      if (timeouts.current.length) {\n        timeouts.current.forEach(function (id) {\n          return clearTimeout(id);\n        });\n        timeouts.current = [];\n      }\n    }; // We dynamically set this so we either clean up on the next effect - or on unmount.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, getHookDeps(opts));\n  return useCallback(function (handler, timeout) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    var id = setTimeout.apply(void 0, [function () {\n      timeouts.current = timeouts.current.filter(function (timeoutId) {\n        return timeoutId !== id;\n      });\n      handler();\n    }, timeout].concat(args));\n    timeouts.current.push(id);\n  }, []);\n};","map":{"version":3,"sources":["D:/unipr/Telematica/Progetto/Telematica/frontend/node_modules/@atlaskit/tooltip/node_modules/@atlaskit/motion/dist/esm/utils/timer-hooks.js"],"names":["useCallback","useEffect","useRef","getHookDeps","opts","cleanup","undefined","useRequestAnimationFrame","arguments","length","frames","current","forEach","id","cancelAnimationFrame","handler","requestAnimationFrame","time","filter","frameId","push","useSetTimeout","timeouts","clearTimeout","timeout","_len","args","Array","_key","setTimeout","apply","timeoutId","concat"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\n\nvar getHookDeps = function getHookDeps(opts) {\n  switch (opts.cleanup) {\n    case 'next-effect':\n      return undefined;\n\n    case 'unmount':\n    default:\n      return [];\n  }\n};\n/**\n * Will return request animation frame as a function which will clean itself up.\n */\n\n\nexport var useRequestAnimationFrame = function useRequestAnimationFrame() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    cleanup: 'unmount'\n  };\n  var frames = useRef([]);\n  useEffect(function () {\n    return function () {\n      if (frames.current.length) {\n        frames.current.forEach(function (id) {\n          return cancelAnimationFrame(id);\n        });\n        frames.current = [];\n      }\n    }; // We dynamically set this so we either clean up on the next effect - or on unmount.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, getHookDeps(opts));\n  return useCallback(function (handler) {\n    var id = requestAnimationFrame(function (time) {\n      frames.current = frames.current.filter(function (frameId) {\n        return frameId !== id;\n      });\n      handler(time);\n    });\n    frames.current.push(id);\n  }, []);\n};\n/**\n * Will return set  timeout as a function which will clean itself up.\n */\n\nexport var useSetTimeout = function useSetTimeout() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    cleanup: 'unmount'\n  };\n  var timeouts = useRef([]);\n  useEffect(function () {\n    return function () {\n      if (timeouts.current.length) {\n        timeouts.current.forEach(function (id) {\n          return clearTimeout(id);\n        });\n        timeouts.current = [];\n      }\n    }; // We dynamically set this so we either clean up on the next effect - or on unmount.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, getHookDeps(opts));\n  return useCallback(function (handler, timeout) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    var id = setTimeout.apply(void 0, [function () {\n      timeouts.current = timeouts.current.filter(function (timeoutId) {\n        return timeoutId !== id;\n      });\n      handler();\n    }, timeout].concat(args));\n    timeouts.current.push(id);\n  }, []);\n};"]},"metadata":{},"sourceType":"module"}