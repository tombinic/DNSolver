"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addCommentBefore = addCommentBefore;
exports.addDynamicImport = exports.addCommentToStartOfFile = void 0;
exports.addToImport = addToImport;
exports.callExpressionArgMatchesString = void 0;
exports.clean = clean;
exports.getJSXAttributesByName = exports.getDynamicImportName = exports.getDefaultSpecifier = exports.doesIdentifierExist = exports.debug = void 0;
exports.getNamedSpecifier = getNamedSpecifier;
exports.getSafeImportName = getSafeImportName;
exports.isEmpty = exports.hasJSXAttributesByName = exports.hasImportDeclarationFromAnyPackageEntrypoint = exports.hasImportDeclaration = void 0;
exports.removeImport = removeImport;
exports.testMethodVariantEach = exports.shiftDefaultImport = void 0;
exports.tryCreateImport = tryCreateImport;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

function getNamedSpecifier(j, source, specifier, importName) {
  var specifiers = source.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === specifier;
  }).find(j.ImportSpecifier).filter(function (path) {
    return path.node.imported.name === importName;
  });

  if (!specifiers.length) {
    return null;
  }

  return specifiers.nodes()[0].local.name;
}

var getDynamicImportName = function getDynamicImportName(j, source, importPath) {
  var dynamicImports = source.find(j.VariableDeclarator).filter(function (variableDeclaratorPath) {
    return j(variableDeclaratorPath).find(j.CallExpression).filter(function (callExpressionPath) {
      var _callExpressionPath$n = callExpressionPath.node,
          callee = _callExpressionPath$n.callee,
          callExpressionArguments = _callExpressionPath$n.arguments;
      return !!(isCallExpressionCalleeImportType(callee) && isCallExpressionArgumentStringLiteralType(callExpressionArguments) && isCallExpressionArgumentValueMatches(callExpressionArguments[0], j, importPath));
    }).length > 0;
  });

  if (!dynamicImports.length) {
    return null;
  }

  var id = dynamicImports.nodes()[0].id;

  if (id.type !== 'Identifier') {
    return null;
  }

  return id.name;
};

exports.getDynamicImportName = getDynamicImportName;

var isCallExpressionCalleeImportType = function isCallExpressionCalleeImportType(callee) {
  return callee && callee.type === 'Import';
};

var isCallExpressionArgumentStringLiteralType = function isCallExpressionArgumentStringLiteralType(callExpressionArguments) {
  return callExpressionArguments && callExpressionArguments.length && callExpressionArguments[0].type === 'StringLiteral';
};

var isCallExpressionArgumentValueMatches = function isCallExpressionArgumentValueMatches(callExpressionArgument, j, value) {
  return j(callExpressionArgument).some(function (path) {
    return path.node.value === value;
  });
};

var addDynamicImport = function addDynamicImport(j, target, name, packageEndpoint) {
  var node = j.variableDeclaration('const', [j.variableDeclarator(j.identifier(name), j.callExpression(j.memberExpression(j.identifier('React'), j.identifier('lazy')), [j.arrowFunctionExpression([], j.callExpression(j.import(), [j.stringLiteral(packageEndpoint)]))]))]);
  target.insertAfter(node);
  addCommentBefore(j, j(node), 'We have added "React.lazy" here. Feel free to change it to "lazy" or other named import depending upon how you imported.');
}; // not replacing newlines (which \s does)


exports.addDynamicImport = addDynamicImport;
var spacesAndTabs = /[ \t]{2,}/g;
var lineStartWithSpaces = /^[ \t]*/gm;

function clean(value) {
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}

var addCommentToStartOfFile = function addCommentToStartOfFile(_ref) {
  var j = _ref.j,
      base = _ref.base,
      message = _ref.message;
  addCommentBefore(j, base.find(j.Program), message);
};

exports.addCommentToStartOfFile = addCommentToStartOfFile;

function addCommentBefore(j, target, message) {
  var commentType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'block';
  var messagePrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'TODO: (from codemod) ';
  var msg = clean(messagePrefix + message);
  var content = commentType === 'block' ? " ".concat(msg, " ") : " ".concat(msg);
  target.forEach(function (path) {
    path.value.comments = path.value.comments || [];
    var exists = path.value.comments.find(function (comment) {
      return comment.value === content;
    }); // avoiding duplicates of the same comment

    if (exists) {
      return;
    }

    if (commentType === 'block') {
      path.value.comments.push(j.commentBlock(content));
    } else {
      path.value.comments.push(j.commentLine(content));
    }
  });
}

var getDefaultSpecifier = function getDefaultSpecifier(j, source, specifier) {
  var specifiers = source.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === specifier;
  }).find(j.ImportDefaultSpecifier);

  if (!specifiers.length) {
    return null;
  }

  return specifiers.nodes()[0].local.name;
}; // @ts-ignore


exports.getDefaultSpecifier = getDefaultSpecifier;

var getJSXAttributesByName = function getJSXAttributesByName(j, element, attributeName) {
  return j(element).find(j.JSXOpeningElement).at(0).find(j.JSXAttribute).filter(function (attribute) {
    var matches = j(attribute).find(j.JSXIdentifier).filter(function (identifier) {
      return identifier.value.name === attributeName;
    });
    return Boolean(matches.length);
  });
};

exports.getJSXAttributesByName = getJSXAttributesByName;

var isEmpty = function isEmpty(string) {
  return string && string.value !== '';
};

exports.isEmpty = isEmpty;

var hasImportDeclaration = function hasImportDeclaration(j, source, importPath) {
  var imports = source.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === importPath;
  });
  return Boolean(imports.length);
};

exports.hasImportDeclaration = hasImportDeclaration;

var hasImportDeclarationFromAnyPackageEntrypoint = function hasImportDeclarationFromAnyPackageEntrypoint(j, source, packageName) {
  var imports = source.find(j.ImportDeclaration).filter(function (path) {
    var _path$node, _path$node$source;

    return (// @ts-ignore
      path === null || path === void 0 ? void 0 : (_path$node = path.node) === null || _path$node === void 0 ? void 0 : (_path$node$source = _path$node.source) === null || _path$node$source === void 0 ? void 0 : _path$node$source.value.toString().startsWith(packageName)
    );
  });
  return Boolean(imports.length);
};

exports.hasImportDeclarationFromAnyPackageEntrypoint = hasImportDeclarationFromAnyPackageEntrypoint;

var debug = function debug(component) {
  return function (j, source) {
    var defaultSpecifier = getDefaultSpecifier(j, source, component);

    if (!defaultSpecifier) {
      return;
    }

    source.findJSXElements(defaultSpecifier).forEach(function (element) {
      console.log(element); //eslint-disable-line no-console
    });
  };
};

exports.debug = debug;

var checkForStringWithFormatSpecifier = function checkForStringWithFormatSpecifier(argValue, str) {
  var value = String(argValue);
  var formatSpecifierRegex = /%[a-z]/g;

  if (value && value.match(formatSpecifierRegex)) {
    var formatSpecifierReplacedStr = value.replace(formatSpecifierRegex, '.*');
    var regex = new RegExp(formatSpecifierReplacedStr);
    return regex.test(str);
  } else {
    return false;
  }
};

var checkForTemplateLiteralsWithPlaceholders = function checkForTemplateLiteralsWithPlaceholders(quasis, str) {
  var templateStrs = quasis.map(function (quasi) {
    return quasi.value.raw.trim();
  }).join('.*');
  var regex = new RegExp(templateStrs);
  return regex.test(str);
};

var callExpressionArgMatchesString = function callExpressionArgMatchesString(arg, str) {
  switch (arg.type) {
    case 'StringLiteral':
    case 'Literal':
      {
        if (arg.value === str) {
          return true;
        } else {
          // Eg: 'should contain %s'
          return checkForStringWithFormatSpecifier(arg.value, str);
        }
      }

    case 'TemplateLiteral':
      {
        // fuzzy match template literals, skipping expressions
        var templateStrs = arg.quasis.map(function (quasi) {
          return quasi.value.raw.trim();
        }).join(' ');

        if (str.trim() === templateStrs.trim()) {
          return true;
        } else {
          // Eg: `should contain ${value}`
          return checkForTemplateLiteralsWithPlaceholders(arg.quasis, str);
        }
      }

    case 'BinaryExpression':
      {
        return false;
      }

    default:
      {
        return false;
      }
  }
};

exports.callExpressionArgMatchesString = callExpressionArgMatchesString;

var testMethodVariantEach = function testMethodVariantEach(path, testMethods) {
  var _path$value, _path$value$callee, _path$value$callee$ca, _path$value2, _path$value2$callee, _path$value2$callee$c, _path$value2$callee$c2, _path$value3, _path$value3$callee, _path$value3$callee$c, _path$value3$callee$c2;

  var variants = new Set(['each']);
  return (// @ts-ignore
    ((_path$value = path.value) === null || _path$value === void 0 ? void 0 : (_path$value$callee = _path$value.callee) === null || _path$value$callee === void 0 ? void 0 : (_path$value$callee$ca = _path$value$callee.callee) === null || _path$value$callee$ca === void 0 ? void 0 : _path$value$callee$ca.type) === 'MemberExpression' && // @ts-ignore
    testMethods.has((_path$value2 = path.value) === null || _path$value2 === void 0 ? void 0 : (_path$value2$callee = _path$value2.callee) === null || _path$value2$callee === void 0 ? void 0 : (_path$value2$callee$c = _path$value2$callee.callee) === null || _path$value2$callee$c === void 0 ? void 0 : (_path$value2$callee$c2 = _path$value2$callee$c.object) === null || _path$value2$callee$c2 === void 0 ? void 0 : _path$value2$callee$c2.name) && // @ts-ignore
    variants.has((_path$value3 = path.value) === null || _path$value3 === void 0 ? void 0 : (_path$value3$callee = _path$value3.callee) === null || _path$value3$callee === void 0 ? void 0 : (_path$value3$callee$c = _path$value3$callee.callee) === null || _path$value3$callee$c === void 0 ? void 0 : (_path$value3$callee$c2 = _path$value3$callee$c.property) === null || _path$value3$callee$c2 === void 0 ? void 0 : _path$value3$callee$c2.name)
  );
};

exports.testMethodVariantEach = testMethodVariantEach;

var hasJSXAttributesByName = function hasJSXAttributesByName(j, element, attributeName) {
  return getJSXAttributesByName(j, element, attributeName).length > 0;
};

exports.hasJSXAttributesByName = hasJSXAttributesByName;

var doesIdentifierExist = function doesIdentifierExist(j, base, name) {
  return base.find(j.Identifier).filter(function (identifer) {
    return identifer.value.name === name;
  }).length > 0;
};

exports.doesIdentifierExist = doesIdentifierExist;

function removeImport(j, base, packageName) {
  base.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === packageName;
  }).remove();
}

function tryCreateImport(j, base, relativeToPackage, packageName) {
  var exists = base.find(j.ImportDeclaration).filter(function (path) {
    return path.value.source.value === packageName;
  }).length > 0;

  if (exists) {
    return;
  }

  base.find(j.ImportDeclaration).filter(function (path) {
    return path.value.source.value === relativeToPackage;
  }).insertBefore(j.importDeclaration([], j.literal(packageName)));
}

function addToImport(j, base, importSpecifier, packageName) {
  base.find(j.ImportDeclaration).filter(function (path) {
    return path.value.source.value === packageName;
  }).replaceWith(function (declaration) {
    return j.importDeclaration([].concat((0, _toConsumableArray2.default)((declaration.value.specifiers || []).filter(function (item) {
      return item.type === 'ImportSpecifier' && item.imported != null;
    })), [importSpecifier]), j.literal(packageName));
  });
}

var shiftDefaultImport = function shiftDefaultImport(j, base, defaultName, oldPackagePath, newPackagePath) {
  tryCreateImport(j, base, oldPackagePath, newPackagePath);
  addToImport(j, base, j.importDefaultSpecifier(j.identifier(defaultName)), newPackagePath); // removing old default specifier

  base.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === oldPackagePath;
  }).remove();
};

exports.shiftDefaultImport = shiftDefaultImport;

function getSafeImportName(_ref2) {
  var j = _ref2.j,
      base = _ref2.base,
      currentDefaultSpecifierName = _ref2.currentDefaultSpecifierName,
      desiredName = _ref2.desiredName,
      fallbackName = _ref2.fallbackName;

  if (currentDefaultSpecifierName === desiredName) {
    return desiredName;
  }

  var isUsed = doesIdentifierExist(j, base, desiredName);
  return isUsed ? fallbackName : desiredName;
}