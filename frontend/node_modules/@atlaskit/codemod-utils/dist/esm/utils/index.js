import { addCommentToStartOfFile, addToImport, getDefaultSpecifier, getJSXAttributesByName, getNamedSpecifier, getSafeImportName, tryCreateImport } from './support';

var createRemoveFuncFor = function createRemoveFuncFor(component, importName, prop) {
  var predicate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {
    return true;
  };
  var comment = arguments.length > 4 ? arguments[4] : undefined;
  return function (j, source) {
    var specifier = getNamedSpecifier(j, source, component, importName);

    if (!specifier) {
      return;
    }

    source.findJSXElements(specifier).forEach(function (element) {
      if (predicate(j, element) && comment) {
        addCommentToStartOfFile({
          j: j,
          base: source,
          message: comment
        });
      } else {
        getJSXAttributesByName(j, element, prop).forEach(function (attribute) {
          j(attribute).remove();
        });
      }
    });
  };
};

var createRenameFuncFor = function createRenameFuncFor(component, from, to) {
  return function (j, source) {
    var defaultSpecifier = getDefaultSpecifier(j, source, component);

    if (!defaultSpecifier) {
      return;
    }

    source.findJSXElements(defaultSpecifier).forEach(function (element) {
      getJSXAttributesByName(j, element, from).forEach(function (attribute) {
        j(attribute).replaceWith(j.jsxAttribute(j.jsxIdentifier(to), attribute.node.value));
      });
    });
  };
};

var createConvertFuncFor = function createConvertFuncFor(component, from, to, predicate) {
  return function (j, source) {
    var defaultSpecifier = getDefaultSpecifier(j, source, component);

    if (!defaultSpecifier) {
      return;
    }

    source.findJSXElements(defaultSpecifier).forEach(function (element) {
      getJSXAttributesByName(j, element, from).forEach(function (attribute) {
        var shouldConvert = predicate && predicate(attribute.node.value) || false;
        var node = j.jsxAttribute(j.jsxIdentifier(to));

        if (shouldConvert) {
          j(attribute).insertBefore(node);
        }
      });
    });
  };
};

var replaceImportStatementFor = function replaceImportStatementFor(pkg, convertMap) {
  return function (j, root) {
    root.find(j.ImportDeclaration).filter(function (path) {
      return path.node.source.value === pkg;
    }).forEach(function (path) {
      var defaultSpecifier = (path.value.specifiers || []).filter(function (specifier) {
        return specifier.type === 'ImportDefaultSpecifier';
      });
      var defaultDeclarations = defaultSpecifier.map(function (s) {
        return j.importDeclaration([s], j.literal(convertMap['default']));
      });
      var otherSpecifier = (path.value.specifiers || []).filter(function (specifier) {
        return specifier.type === 'ImportSpecifier';
      });
      j(path).replaceWith(defaultDeclarations);
      var otherDeclarations = otherSpecifier.map(function (s) {
        var localName = s.local.name;

        if (convertMap[localName]) {
          return j.importDeclaration([j.importDefaultSpecifier(j.identifier(localName))], j.literal(convertMap[localName]));
        } else {
          return j.importDeclaration([j.importDefaultSpecifier(j.identifier(localName))], j.literal(convertMap['*']));
        }
      });
      j(path).insertAfter(otherDeclarations);
    });
  };
};

var createRenameImportFor = function createRenameImportFor(component, from, to) {
  return function (j, source) {
    source.find(j.ImportDeclaration).filter(function (path) {
      return path.node.source.value === component;
    }).forEach(function (path) {
      j(path).replaceWith(j.importDeclaration(path.value.specifiers, j.literal(to)));
    });
  };
};

var createTransformer = function createTransformer(migrates, shouldApplyTransform) {
  return function (fileInfo, _ref, options) {
    var j = _ref.jscodeshift;
    var source = j(fileInfo.source); // If shouldApplyTransform not provided then perform old behaviour

    if (!shouldApplyTransform || shouldApplyTransform(j, source)) {
      migrates.forEach(function (tf) {
        return tf(j, source);
      });
      return source.toSource(options.printOptions);
    }

    return fileInfo.source;
  };
};

var elevateComponentToNewEntryPoint = function elevateComponentToNewEntryPoint(pkg, toPkg, innerElementName) {
  return function (j, root) {
    var importDeclarations = root.find(j.ImportDeclaration).filter(function (path) {
      return path.node.source.value === pkg;
    });
    var defaultSpecifier = importDeclarations.find(j.ImportDefaultSpecifier).nodes();
    var otherSpecifier = importDeclarations.find(j.ImportSpecifier).nodes();
    var newDefaultSpecifier = defaultSpecifier.map(function (s) {
      return j.importDeclaration([j.importDefaultSpecifier(s.local)], j.literal(pkg));
    });
    var newOtherSpecifiers = otherSpecifier.map(function (s) {
      if (s.imported.name === innerElementName) {
        return j.importDeclaration([j.importDefaultSpecifier(s.local)], j.literal(toPkg));
      } else {
        return j.importDeclaration([s], j.literal(pkg));
      }
    });
    importDeclarations.forEach(function (path) {
      j(path).replaceWith(newDefaultSpecifier);
      j(path).insertBefore(newOtherSpecifiers);
    });
  };
};

var flattenCertainChildPropsAsProp = function flattenCertainChildPropsAsProp(component, propName, childProps) {
  return function (j, source) {
    var defaultSpecifier = getDefaultSpecifier(j, source, component);

    if (!defaultSpecifier) {
      return;
    }

    source.findJSXElements(defaultSpecifier).forEach(function (element) {
      getJSXAttributesByName(j, element, propName).forEach(function (attribute) {
        j(attribute).find(j.JSXExpressionContainer).find(j.ObjectExpression).forEach(function (objectExpression) {
          objectExpression.node.properties.forEach(function (property) {
            childProps.forEach(function (childProp) {
              if ((property.type === 'Property' || property.type === 'ObjectProperty') && property.key.type === 'Identifier' && property.key.name === childProp) {
                var _element$node$opening;

                (_element$node$opening = element.node.openingElement.attributes) === null || _element$node$opening === void 0 ? void 0 : _element$node$opening.push(j.jsxAttribute(j.jsxIdentifier(childProp), j.jsxExpressionContainer(property.value)));
              }
            });
          });
        });
      });
    });
  };
};

var createRenameJSXFunc = function createRenameJSXFunc(packagePath, from, to) {
  var fallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
  return function (j, source) {
    var namedSpecifier = getNamedSpecifier(j, source, packagePath, from);
    var toName = fallback ? getSafeImportName({
      j: j,
      base: source,
      currentDefaultSpecifierName: namedSpecifier,
      desiredName: to,
      fallbackName: fallback
    }) : to;
    var existingAlias = source.find(j.ImportDeclaration).filter(function (path) {
      return path.node.source.value === packagePath;
    }).find(j.ImportSpecifier).nodes().map(function (specifier) {
      if (from !== specifier.imported.name) {
        return null;
      } // If aliased: return the alias


      if (specifier.local && from !== specifier.local.name) {
        return specifier.local.name;
      }

      return null;
    }).filter(Boolean)[0] || null;
    source.find(j.ImportDeclaration).filter(function (path) {
      return path.node.source.value === packagePath;
    }).find(j.ImportSpecifier).filter(function (importSpecifier) {
      var identifier = j(importSpecifier).find(j.Identifier).get();

      if (from === identifier.value.name || existingAlias === identifier.value.name) {
        return true;
      }

      return false;
    }).replaceWith([j.importSpecifier(j.identifier(toName), existingAlias ? j.identifier(existingAlias) : null)], j.literal(packagePath));
  };
};

var createRemoveFuncAddCommentFor = function createRemoveFuncAddCommentFor(component, prop, comment) {
  return function (j, source) {
    var defaultSpecifier = getDefaultSpecifier(j, source, component);

    if (!defaultSpecifier) {
      return;
    }

    source.findJSXElements(defaultSpecifier).forEach(function (element) {
      getJSXAttributesByName(j, element, prop).forEach(function (attribute) {
        j(attribute).remove();

        if (comment) {
          addCommentToStartOfFile({
            j: j,
            base: source,
            message: comment
          });
        }
      });
    });
  };
};

var renameNamedImportWithAliasName = function renameNamedImportWithAliasName(component, from, to) {
  return function (j, source) {
    source.find(j.ImportDeclaration).filter(function (path) {
      return path.node.source.value === component;
    }).find(j.ImportSpecifier).filter(function (path) {
      return path.node.imported.name === from;
    }).forEach(function (path) {
      var localName = path.node.local.name;
      j(path).replaceWith(j.importSpecifier(j.identifier(to), j.identifier(localName)));
    });
  };
};

var changeImportEntryPoint = function changeImportEntryPoint(oldPackageName, importToConvert, newPackageName) {
  return function (j, root) {
    root.find(j.ImportDeclaration, {
      source: {
        value: oldPackageName
      }
    }).forEach(function (path) {
      var _currentImportSpecifi;

      var currentImportSpecifier = (path.value.specifiers || []).find(function (specifier) {
        if (specifier.type === 'ImportSpecifier') {
          return specifier.imported.name === importToConvert;
        }

        return false;
      });

      if (!currentImportSpecifier) {
        return;
      }

      var importedSpecifierName = currentImportSpecifier.imported.name;
      var localSpecifierName = (_currentImportSpecifi = currentImportSpecifier.local) === null || _currentImportSpecifi === void 0 ? void 0 : _currentImportSpecifi.name;
      var newIdentifier = j.importSpecifier(j.identifier(importedSpecifierName), localSpecifierName ? j.identifier(localSpecifierName) : undefined); // check if new import exists, if not create it

      tryCreateImport(j, root, oldPackageName, newPackageName); // remove the old import specifier, but NOT the whole package

      root.find(j.ImportDeclaration, {
        source: {
          value: oldPackageName
        }
      }).find(j.ImportSpecifier).filter(function (path) {
        return path.value.imported.name === importToConvert;
      }).remove(); // adds import specifier to new import

      addToImport(j, root, newIdentifier, newPackageName); // if there are any imports with no specifiers, remove the whole import

      root.find(j.ImportDeclaration, {
        source: {
          value: oldPackageName
        }
      }).filter(function (path) {
        var _path$value$specifier;

        return !((_path$value$specifier = path.value.specifiers) !== null && _path$value$specifier !== void 0 && _path$value$specifier.length);
      }).remove();
    });
  };
};

export { createRenameFuncFor, createConvertFuncFor, createRenameImportFor, createRemoveFuncFor, replaceImportStatementFor, elevateComponentToNewEntryPoint, createTransformer, renameNamedImportWithAliasName, flattenCertainChildPropsAsProp, createRenameJSXFunc, createRemoveFuncAddCommentFor, changeImportEntryPoint };